#include <catch2/catch_test_macros.hpp>
#include <iostream>

#include "JkBmsFrames.h"
#include "CppWrappers.h"
#include "JkBmsTools.h"

using namespace JkBmsCpp;


constexpr uint8_t SAMPLE_CELL_INFO_FRAME[] = {
    0x55, 0xaa, 0xeb, 0x90, 
    0x02, 
    0x89,
    // cellVoltages_mV
    0xff, 0x0c, 0xff, 0x0c, 0xff, 0x0c, 0xfe, 0x0c, 
    0xff, 0x0c, 0xfe, 0x0c, 0xfe, 0x0c, 0xfe, 0x0c, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,    
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    // enabledCellMask 70
    0xff, 0x00, 0x00, 0x00, 
    
    0xfe, 0x0c, //Average cell voltage, 74
    0x03, 0x00, // Delta Cell Voltage, 76
    0x00,  // Max voltage cell, 78
    0x01, // Min voltage cell, 79
    
    // cell resistances_mOhm, 80
    0x98, 0x00, 0x9b, 0x00, 0x9e, 0x00, 0x9f, 0x00, 
    0x9c, 0x00, 0x95, 0x00, 0x93, 0x00, 0x94, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // Power tube temperature, 144
    0xe3, 0x00, //22.7

    // Wire resistance warning bitmask, 146
    0x00, 0x00, 0x00, 0x00,
    // Battery voltage, 150
    0xf0, 0x67, 0x00, 0x00, // 26.6v
    // Battery power, 154
     0x4c, 0x13, 0x00, 0x00,
    // charge current, 158
    0x46, 0xff, 0xff, 0xff, // -186mA
    
    // temperature sensor 1, 162
    0xdd, 0x00,
    // temperature sensor 2, 164
    0xe6, 0x00,

    // Errors bitmask, 166
    0x00, 0x00, 
    // ???, 168
    0x00, 0x00, 
    // Balance current, 170
    0x00, 0x00,
    // Balancing action, 172
    0x00, 
    
    // State of charge, 173
    0x63,
    // Remaining capacity, 174
    0x7c, 0x21, 0x01, 0x00, 
    // Nominal capacity, 178
    0xf9, 0x22, 0x01, 0x00,


    0x2a, 0x00, 0x00, 0x00, 0xfb, 0x51, 0x30, 0x00, 
    0x56, 0x00, 0x00, 0x00, 0x4b, 0x60, 0x0d, 0x01,
    0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xff, 0x00, 0x01, 0x00, 0x00, 0x00, 0xa6, 0x03, 
    0x00, 0x00, 0x01, 0x00, 0x02, 0x58, 0x40, 0x40,
    0x00, 0x00, 0x00, 0x00, 0x64, 0x0a, 0xcb, 0x1d, 
    0x00, 0x01, 0x00, 0x01, 0xba, 0x05, 0x00, 0x00,
    0x2d, 0x99, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0xe3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0xfe, 0xff, 0x7f, 0xdc, 0x0f, 0x01, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x08
};

constexpr uint8_t SAMPLE_DEVICE_INFO_FRAME[] = {
0x55, 0xaa, 0xeb, 0x90, 
0x03, 
0x4b, 
0x4a, 0x4b, 0x5f, 0x42, 0x44, 0x36, 0x41, 0x32, 0x30, 0x53, 0x31, 0x30, 0x50, 0x00, 0x00, 0x00, 
0x31, 0x31, 0x2e, 0x58, 0x57, 0x00, 0x00, 0x00, 
0x31, 0x31, 0x2e, 0x32, 0x38, 0x31, 0x00, 0x00, 
0xa8, 0x6b, 0x09, 0x01, // uptimeSeconds
0x35, 0x00, 0x00, 0x00, // powerOnCounter
0x4a, 0x4b,
0x5f, 0x42, 0x44, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x30, 0x50, 0x00, 0x00, 0x00, 0x31, 0x31,
0x31, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x34,
0x30, 0x36, 0x30, 0x38, 0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x31,
0x00, 0x30, 0x30, 0x30, 0x30, 0x00, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x55, 0x73, 0x65, 0x72,
0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x66,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x20, 0x55, 0x73, 0x65, 0x72,
0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
0xfc, 0xf9, 0xff, 0xff, 0x1f, 0x2d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x0f, 0x00, 0x00,
0x00, 0x00, 0xc0, 0xd8, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x6c
};
    

TEST_CASE("checkFrameStart", "[JkBmsFrames]") {
    uint8_t correctBuffer[] = {0x55, 0xaa, 0xeb, 0x90, 0x00};
    JkBmsCpp::JkBmsDataBuffer buffer1(correctBuffer, 5);    
    REQUIRE(JkBmsCpp::checkFrameStart(buffer1) == true);

    uint8_t incorrectBuffer[] = {0x22, 0xaa, 0xeb, 0x90, 0x00};
    JkBmsCpp::JkBmsDataBuffer buffer2(incorrectBuffer, 5);
    REQUIRE(JkBmsCpp::checkFrameStart(buffer2) == false);

    JkBmsCpp::JkBmsDataBuffer buffer3((uint8_t*)SAMPLE_DEVICE_INFO_FRAME, 
        sizeof(SAMPLE_DEVICE_INFO_FRAME));    
    REQUIRE(JkBmsCpp::checkFrameStart(buffer3) == true);
}

TEST_CASE("checkFrameChecksum", "[JkBmsFrames]") {
    uint8_t correctBuffer[] = {0x55, 0xaa, 0xeb, 0x90, 0x01, 0x7b};
    JkBmsCpp::JkBmsDataBuffer buffer1(correctBuffer, 6);    
    REQUIRE(JkBmsCpp::checkFrameChecksum(buffer1) == true);

    uint8_t incorrectBuffer[] = {0x55, 0xaa, 0xeb, 0x90, 0x01, 0x2f};
    JkBmsCpp::JkBmsDataBuffer buffer2(incorrectBuffer, 6);    
    REQUIRE(JkBmsCpp::checkFrameChecksum(buffer2) == false);

    JkBmsCpp::JkBmsDataBuffer buffer3((uint8_t*)SAMPLE_DEVICE_INFO_FRAME, 
        sizeof(SAMPLE_DEVICE_INFO_FRAME));    
    REQUIRE(JkBmsCpp::checkFrameChecksum(buffer3) == true);
}

TEST_CASE("parseDeviceInfo", "[JkBmsFrames]") {
    JkBmsCpp::JkBmsDataBuffer buffer((uint8_t*)SAMPLE_DEVICE_INFO_FRAME, 
        sizeof(SAMPLE_DEVICE_INFO_FRAME));
    auto deviceInfo = JkBmsCpp::parseDeviceInfo(buffer);
    REQUIRE(deviceInfo.hasValue() == true);
    auto info = deviceInfo.value();
    REQUIRE(info.vendorId == "JK_BD6A20S10P");
    REQUIRE(info.hwVersion == "11.XW");
    REQUIRE(info.swVersion == "11.281");
    REQUIRE(info.uptimeSeconds == 0x1096ba8);
    REQUIRE(info.powerOnCounter == 53);
    REQUIRE(info.deviceName == "JK_BD1234560P");
    REQUIRE(info.devicePasscode == "1111");
    REQUIRE(info.manufacturedate == "240608");
    REQUIRE(info.serialNumber == "1234567891");
}

TEST_CASE("parseCellsInfo", "[JkBmsFrames]") {
    JkBmsCpp::JkBmsDataBuffer buffer((uint8_t*)SAMPLE_CELL_INFO_FRAME, 
        sizeof(SAMPLE_CELL_INFO_FRAME));
    auto cellsInfo = JkBmsCpp::parseCellsInfo(buffer);
    REQUIRE(cellsInfo.hasValue() == true);
    auto& info = cellsInfo.value();
    REQUIRE(info.cellVoltages_mV[0] == 3327);
    REQUIRE(info.cellVoltages_mV[1] == 0xcff);
    REQUIRE(info.cellVoltages_mV[2] == 0xcff);
    REQUIRE(info.cellVoltages_mV[3] == 3326);
    REQUIRE(info.cellVoltages_mV[4] == 0xcff);
    REQUIRE(info.cellVoltages_mV[5] == 3326);
    REQUIRE(info.cellVoltages_mV[6] == 3326);
    REQUIRE(info.cellVoltages_mV[7] == 3326);
    REQUIRE(info.cellVoltages_mV[8] == 0x00);

    REQUIRE(info.enabledCellMask == 0xFF);
    REQUIRE(info.averageCellVoltage_mV== 0x0cfe);
    REQUIRE(info.deltaCellVoltage_mV== 0x0003);
    REQUIRE(info.maxVoltageCellIndex== 0x00);
    REQUIRE(info.minVoltageCellIndex== 0x01);

    REQUIRE(info.cellResistances_mOhm[0] == 152);
    REQUIRE(info.cellResistances_mOhm[1] == 155);
    REQUIRE(info.cellResistances_mOhm[2] == 158);
    REQUIRE(info.cellResistances_mOhm[3] == 159);
    REQUIRE(info.cellResistances_mOhm[4] == 156);
    REQUIRE(info.cellResistances_mOhm[5] == 149);
    REQUIRE(info.cellResistances_mOhm[6] == 147);
    REQUIRE(info.cellResistances_mOhm[7] == 148);
    REQUIRE(info.cellResistances_mOhm[8] == 0x00);

    REQUIRE(info.powerTubeTemperature == 227);
    REQUIRE(info.batteryVoltage_mV == 26608);
    REQUIRE(info.chargeCurrent_mA == -186);
    REQUIRE(info.temperatureSensor1 == 221);
    REQUIRE(info.temperatureSensor2 == 230);
    REQUIRE(info.errorsMask == 0);
    REQUIRE(info.balanceCurrent_mA == 0);
    REQUIRE(info.balanceAction == 0);


    REQUIRE(info.batteryPower_mW == 4940);


    REQUIRE(info.batteryPercentage == 99);
    REQUIRE(info.remainingCapacity_mAh == 74108);
    REQUIRE(info.fullCapacity_mAh == 74489);
}

TEST_CASE("calculateCRC", "[JkBmsFrames]") {
    uint8_t byteBuffer[20];
    JkBmsCpp::JkBmsDataBuffer buffer(byteBuffer, sizeof(byteBuffer));
    prepareCommandBuffer(0x96, 0, 0, buffer);
    uint8_t crc = JkBmsCpp::calculateCRC(JkBmsCpp::JkBmsDataBuffer(buffer.data(), buffer.size() - 1));
    REQUIRE(crc == 0x10);
}

TEST_CASE("prepareCommandBuffer", "[JkBmsFrames]") {
    uint8_t byteBuffer[20];
    JkBmsCpp::JkBmsDataBuffer buffer(byteBuffer, sizeof(byteBuffer));
    prepareCommandBuffer(0x38, 0x12345678, 4, buffer);
    REQUIRE(byteBuffer[0] == 0xaa);
    REQUIRE(byteBuffer[1] == 0x55);
    REQUIRE(byteBuffer[2] == 0x90);
    REQUIRE(byteBuffer[3] == 0xeb);
    REQUIRE(byteBuffer[4] == 0x38);
    REQUIRE(byteBuffer[5] == 0x04);
    REQUIRE(byteBuffer[6] == 0x78);
    REQUIRE(byteBuffer[7] == 0x56);
    REQUIRE(byteBuffer[8] == 0x34);
    REQUIRE(byteBuffer[9] == 0x12);
    REQUIRE(byteBuffer[10] == 0x00);
    REQUIRE(byteBuffer[11] == 0x00);
    REQUIRE(byteBuffer[12] == 0x00);
    REQUIRE(byteBuffer[13] == 0x00);
    REQUIRE(byteBuffer[14] == 0x00);
    REQUIRE(byteBuffer[15] == 0x00);
    REQUIRE(byteBuffer[16] == 0x00);
    REQUIRE(byteBuffer[17] == 0x00);
    REQUIRE(byteBuffer[18] == 0x00);
    std::cout << "Calculated CRC: " << std::hex << (int)byteBuffer[19] << std::dec << std::endl;    
    REQUIRE(byteBuffer[19] == 0xca); // checksum
}

TEST_CASE("getResponseType tests", "[JkBmsFrames]") {
    
    SECTION("Valid CELL_INFO response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90, 0x02}; // CELL_INFO = 0x02
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE(result.hasValue());
        REQUIRE(result.value() == JkBmsResponseType::CELL_INFO);
    }
    
    SECTION("Valid DEVICE_INFO response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90, 0x03}; // DEVICE_INFO = 0x03
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE(result.hasValue());
        REQUIRE(result.value() == JkBmsResponseType::DEVICE_INFO);
    }
    
    SECTION("Valid SETTINGS response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90, 0x01}; // SETTINGS = 0x01
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE(result.hasValue());
        REQUIRE(result.value() == JkBmsResponseType::SETTINGS);
    }
    
    SECTION("Invalid magic bytes") {
        std::vector<uint8_t> buffer = {0x54, 0xaa, 0xeb, 0x90, 0x02}; // Wrong first byte
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE_FALSE(result.hasValue());
        REQUIRE(result.error() == JkBmsControllerError::INVALID_MAGIC_BYTES);
    }
    
    SECTION("Buffer too small") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb}; // Only 3 bytes
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE_FALSE(result.hasValue());
        REQUIRE(result.error() == JkBmsControllerError::INVALID_MAGIC_BYTES);
    }
    
    SECTION("Buffer exactly 4 bytes - missing response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90}; // Missing response type byte
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE_FALSE(result.hasValue());
        REQUIRE(result.error() == JkBmsControllerError::INVALID_RESPONSE_TYPE);
    }
    
    SECTION("Invalid response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90, 0xFF}; // Invalid response type
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE_FALSE(result.hasValue());
        REQUIRE(result.error() == JkBmsControllerError::INVALID_RESPONSE_TYPE);
    }
    
    SECTION("Another invalid response type") {
        std::vector<uint8_t> buffer = {0x55, 0xaa, 0xeb, 0x90, 0x00}; // Invalid response type
        JkBmsDataBuffer dataBuffer(buffer.data(), buffer.size());
        
        auto result = getResponseType(dataBuffer);
        REQUIRE_FALSE(result.hasValue());
        REQUIRE(result.error() == JkBmsControllerError::INVALID_RESPONSE_TYPE);
    }
}